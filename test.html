<p>一篇科普文，写给对gRPC组件仍然存在困惑的同学，希望大家看完本文对于日常gRPC相关的异常与问题都能够游刃有余的处理。如果有更多关于gRPC易用性的建议可以提给基础架构组或提PR给我们。本文有描述不准确的地方或者有疑惑可以留言。本文主要涵盖内容包括：</p><ol><li>gRPC是什么？</li><li>gRPC跟ProtoBuf什么关系，桩代码生成是如何实现的？</li><li>gRPC跟Netty什么关系，线程模型及切换是怎么做的？</li><li>gRPC常见异常类型与分析</li><li>gRPC高阶玩法</li><li>gRPC的生态圈</li></ol><p><br></p><h1>gRPC是什么？</h1><p>gRPC是一款高性能开源通用的RPC框架，同时面向服务端跟移动端，基于HTTP/2协议设计。gRPC<strong><u>不是</u></strong>一款服务治理框架，但是提供了服务治理的若干原材料，例如客户端负载均衡、KeepAlive、流控（自动跟手动）等等。下面简单介绍一下何为<strong>RPC框架</strong>，gRPC作为RPC框架的特点和依赖的重要协议 -- <strong>HTTP/2协议</strong>。</p><p><br></p><h2><strong>RPC框架</strong></h2><p><br></p><img width=\"541\" id=\"tqnb1o8n\" src=\"https://kstack.corp.kuaishou.com/tech/api/file/275d422e-7fcf-46c9-b8fb-afed4f4aca81?alt=auto\"><p><br></p><p>一个RPC框架的基本构成如上图（盗图..）所示，主要包括如下几个部分：</p><h3><strong>序列化协议</strong></h3><p>万物皆字节，我们需要一种途径将万物转化为字节序列在网络传输，这个转化器便是序列化协议，常见如Java原生序列化协议、Thrift、Hession、Json/XML、ProtoBuf。</p><h3><strong>传输层</strong></h3><p>目前而言主要是TCP/UDP，对于Java生态而言大多使用NettyAPI来屏蔽底层实现细节</p><h3><strong>动态代理层</strong></h3><p>屏蔽业务感知远程调用，等同于一个本地服务调用一般</p><p><br></p><h2><strong>gRPC特色</strong></h2><ol><li>支持多语言（其实是每个语言实现了一遍...）</li><li>基于IDL定义服务，即proto文件（其实是使用了Protocol Buffers协议，ProtoBuf也没大家想象中的那么好，第二章节会进行说明），每个语言提供一个代码生成工具，因此可以基于同一份proto生成不同语言的文件从而支持跨语言使用</li><li>序列化支持PB、JSON等，支持自定义Marshaller</li><li>Client支持Netty跟Okhttp（一般给客户端使用的），Server是Netty；同时Client与Server都支持InProcess方式调用（可以理解为Mock）</li><li>暴露较多LowLevel API（类似StreamObserver，XXXCall之类的给使用者），在<strong>gRPC API设计思路</strong>子节中会详细讲解它为何这么做</li><li>对于实现全链路异步而言，个人认为gRPC是首选，会在第五章进行详细介绍如果实现Reactive-gRPC</li></ol><p><br></p><h2><strong>HTTP/2协议简介</strong></h2><p>想要理解好gRPC必须了解HTTP/2协议，因为不论是日常看到的异常栈还是gRPC涉及的相关定义都跟HTTP/2存在强绑定的关系。关于HTTP/2详细介绍请参见：https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-CN</p><p>本文简单介绍跟gRPC息息相关的几个概念:</p><h3><strong>协议协商</strong></h3><ol><li>HTTP/2部署需要基于HTTPS是当前主流浏览器的要求，但是并非强制，因此主要包括如下两种协商类型：</li><li class=\"ql-indent-1\">基于TLS的HTTP/2协议，使用h2标识（ALPN）</li><li class=\"ql-indent-1\">基于TCP的HTTP/2协议，使用h2c标识</li><li>gRPC客户端跟服务端建立连接时会进行协议协商，过程如下：</li><li class=\"ql-indent-1\">客户端在不确定服务端是否支持HTTP/2的情况下发起协商升级请求，如果服务端支持HTTP/2会通过header带回来Upgrade：h2/h2c标识，如果不支持就默认按照HTTP/1.1返回</li><li class=\"ql-indent-1\">协议协商成功后，如果使用HTTP/2协议双方会互发SETTINGS帧（下面会介绍）作为连接序言，回执后开始发送数据，Client侧可以不必等待Server的回执来提高效率</li><li>gRPC支持的三种协议协商策略</li><li class=\"ql-indent-1\"><strong>PlainText</strong>：明确服务端支持HTTP/2协议，省去上述协商升级过程，直接通过SETTINGS帧作为连接序言建立连接后即可发送数据帧</li><li class=\"ql-indent-1\"><strong>PlainTextUpgrade：</strong>不清楚服务端是否支持HTTP/2，即2中描述的内容</li><li class=\"ql-indent-1\"><strong>TLS</strong>：基于TLS建立HTTP/2连接，协商采用ALPN扩展协议，以h2作为标识，譬如跟KeyCenter交互</li></ol><p><br></p><h3><strong>消息头压缩（HPACK）</strong></h3><ol><li>简单来讲就是原先HTTP/1.1中的Content-Type、Content-Encoding等Key都被赋予一个标准的序号（索引）来减少数据量，Value则进行相应的编码（哈夫曼）从而提升传输效率，gRPC默认限制HeaderList的大小为<strong>8192</strong>，即不能超过<strong>8192</strong>个K-V</li></ol><p><br></p><h3><strong>多路复用（Stream概念）</strong></h3><ol><li>这里多路复用是指多个请求使用同一个连接互相不干扰，跟操作系统select/epoll的多路复用不是一个概念</li><li>在HTTP/1.X里面双方想并行发多个请求必须占用多个连接，占用连接资源；同时FIFO的方式如果前面请求处理时间长也会导致队首阻塞（<strong>需要明确的是这里不是指TCP的队首阻塞，HTTP/2解决不了TCP队首阻塞问题，HTTP/3可以</strong>）问题，效率低下；HTTP/2通过抽象Stream概念来实现多路请求复用同一连接</li><li>HTTP/2中双方建立连接之后，每个实际报文请求可以理解为一个Stream，一个Stream又分成若干个Frame（帧是最小的传输单元），数据传输主要包括Header Frame跟Data Frame。每个Stream都分配一个StreamId。gRPC内部也是通过StreamId来识别不同请求的报文</li><li>常见的帧类型：</li><li class=\"ql-indent-1\"><strong>SETTINGS</strong>帧：用于设置连接级别的配置，协议协商与流控窗口变更相关依赖于它</li><li class=\"ql-indent-1\"><strong>PING</strong>帧：用于心跳保持，gRPC KeepAlive就是利用这个帧实现</li><li class=\"ql-indent-1\"><strong>GOAWAY</strong>帧：发起关闭连接请求时候使用，通常是连接达到IDLE状态之后</li><li class=\"ql-indent-1\"><strong>RST_STREAM</strong>帧：关闭当前流的帧，gRPC会经常用到，特别是当错误发生的时候</li><li class=\"ql-indent-1\"><strong>WINDOW_UPDATE</strong>帧：流控帧，gRPC的流控实现依赖于它</li><li class=\"ql-indent-1\"><strong>DATA</strong>帧：实际传输数据帧，如果数据发送完毕会带END_STEAM标识</li><li class=\"ql-indent-1\"><strong>HEADER</strong>帧：消息头帧，通常是一个请求开始帧，基于此帧创建请求初始化相关内容</li></ol><p><br></p><h3><strong>流控机制</strong></h3><ol><li>流控机制是确保同一个TCP连接上的Stream不会互相干扰，因为TCP毕竟也有其局限性</li><li>流控机制同时作用于单个Stream和整个连接，对于Stream而言只作用于Data帧（保证不影响重要帧）</li><li>初始窗口大小都是65535字节，发送端需要严格遵守接收端的窗口限制，连接序言中可以通过SETTINGS帧设置<strong>SETTINGS_INITIAL_WINDOW_SIZE</strong>来指定Stream的初始窗口大小，但是无法配置连接级别的初始窗口大小，gRPC支持设置初始窗口的大小，后续文章内容会详细介绍</li><li>gRPC通过<strong>WINDOW_UPDATE</strong>帧来实现流量控制，但相关说明如下</li><li class=\"ql-indent-1\">gRPC支持自定义流控但默认没开启，仍处于VisableForTesting阶段；使用Netty内置的默认流控功能：基本思路就是当已经处理过的数据超过窗口一半是就发送WINDOW_UPADTE来更新窗口</li><li class=\"ql-indent-1\">gRPC默认流控初始窗口大小是1M</li><li class=\"ql-indent-1\">gRPC如果开启KeepAlive功能那么Ping也会占用窗口大小</li><li class=\"ql-indent-1\">gRPC默认给每个Stream分配的字节数是16K</li><li class=\"ql-indent-1\">gRPC内部支持的自动跟手动流控，只是针对gRPC本身而言，这里流控的含义是Client何时发起从buffer中读取需要数据的请求，类似于一种应用层级的流控，默认是自动的，当有特殊需求时可以开启手动控制，但是比较复杂而且容易出错，不推荐使用</li></ol><p><br></p><h2><strong>gRPC API设计思路（Java-Only）</strong></h2><p>如前面所述，gRPC整体设计思路依附于HTTP/2协议，而HTTP/2是一个双向流协议，因此gRPC在API设计上也采用了Stream的方式。通常意义上（Unary）一次gRPC请求可以理解为一个Stream创建到销毁的过程，框架内部封装了Stream的整个生命周期，暴露给用户的是何时发送数据以及何时完成发送，因此gRPC通过暴露给业务Listener的方式来完成这项工作。看到这里你会问：\"为什么Unary模式也要暴露StreamAPI给用户？\"，答案很简单，就是为了API设计上的一致性，毕竟是框架。因为是双向流协议，因此可以分成如下四种调用模式：</p><ol><li>Unary模式：即请求响应模式</li><li>Client Streaming模式：Client发送多次，Server回复一次</li><li>Server Streaming模式：Client发送一次，Server发送多次</li><li>双向 Streaming模式：Client/Server都发送多次</li></ol><p>下面将分成Server跟Client两部分进行详细描述gRPC API设计（<strong>使用Unary模式进行说明</strong>）</p><h3><strong>Server部分</strong></h3><p>Server端我们能接触到API包括：</p><ol><li>StreamObserver</li><li>ServerCall</li><li>ServerCall.Listener</li></ol><p>下面结合一些使用例子来具体说明一下三者的功能定位跟联系。通常我们通过proto文件定义好service之后会生成一下XXXGrpc.class文件（先不讨论是怎么生成的），里面提供了一个XXXImplBase抽象类，我只需继承该抽象类然后实现方法即可，例如：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">margin</span><span class=\"hljs-params\">(RecoHotMarginReq request, StreamObserver responseObserver)</span> </span>{\n    <span class=\"hljs-keyword\">final</span> List resp = hide(request.getUserId(), request.getDeviceId(),\n            request.getLlsid(), request.getMixResultList(), request.getRecentUploadBitmap());\n    responseObserver.onNext(RecoHotMarginResp.newBuilder().addAllMixResult(resp).build());\n    responseObserver.onCompleted();\n}\n</pre><p>这里我们我们会看到一个叫StreamObserver的东西，先贴出源码并加注释说明：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">StreamObserver</span>&lt;<span class=\"hljs-title\">V</span>&gt;  </span>{\n  \n  <span class=\"hljs-comment\">//代表发送一个完整的数据，但不一定是一次完整请求</span>\n  ﻿<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(V value)</span></span>;\n\n  <span class=\"hljs-comment\">//代表本次请求出现问题，给对方回执一个异常，这个异常会被序列化到对端进行回放</span>\n﻿  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable t)</span></span>;\n\n  <span class=\"hljs-comment\">//代表本次请求已经完成，由于TCP是全双工的，因此仅仅代表当前端不会再继续发送消息//否则会报错</span>\n  ﻿<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCompleted</span><span class=\"hljs-params\">()</span></span>;\n}\n\n</pre><p>对于我们而言，能使用就这仨方法，<strong>需要注意的是onError/onCompleted都是终止请求的回调，我们不能既调用onError又调用onCompleted。</strong>StreamObserver作为一个Stream的观察者似乎能做的不多，gRPC类似其他RPC框架提供一套Interceptor机制，通过Interceptor我们可以操作更多的API或者说HOOK上一次请求更多的流程。</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">ServerInterceptor</span> {\n  <span class=\"hljs-comment\">//顾名思义，Call代表一次请求，下面会分析一下这个方法每个参数的含义</span>\n   ServerCall.<span class=\"hljs-function\">Listener <span class=\"hljs-title\">interceptCall</span>(<span class=\"hljs-params\">\n      ServerCall call,\n      Metadata headers,\n      ServerCallHandler next</span>)</span>;\n}\n\n</pre><p><br></p><p>ServerCall代表Server的一次请求，整理其核心API如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServerCall</span> {\n \n  <span class=\"hljs-comment\">//代表给客户端回发Reponse Headerspublic abstract void sendHeaders(Metadata headers);﻿   </span>\n  \n  <span class=\"hljs-comment\">//代表给客户端返回实际消息数据public abstract void sendMessage(RespT message); </span>\n\n  <span class=\"hljs-comment\">//代表当前请求在服务端已经结束，不会再接收或发送请求，请求成功与否取决于Status的具体值//Status后续我们会详细介绍</span>\n  ﻿﻿<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">close</span>(<span class=\"hljs-params\">Status status, Metadata trailers</span>)</span>;\n\n}\n</pre><p><br></p><p>ServerCall.Listener代表ServerCall的Listener，服务于整个请求生命周期，整理其核心API如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Listener</span> {\n  \n  <span class=\"hljs-comment\">//代表收到客户端请求的消息public void onMessage(ReqT message) {}</span>\n\n  <span class=\"hljs-comment\">//代表Client完成全部消息发送，不会再发更多，也代表服务端需要开始处理请求了</span>\n﻿  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onHalfClose</span>()</span> {}\n\n  <span class=\"hljs-comment\">//代表本次请求被取消掉，通常发生在服务端执行出现异常的情况会被调用</span>\n﻿  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCancel</span>()</span> {}\n\n  <span class=\"hljs-comment\">//代表本次请求正常结束</span>\n  ﻿<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onComplete</span>()</span> {}\n\n}\n</pre><p>综上所述我们完整看到了三个组件提供的完整API，下面详细讲解一下三者API是如何联动的。按照一次请求在Server的完整流程，大致的执行顺序如下：</p><ol><li>Listener.onMessage被执行，代表服务端已经收到客户端一个完整的Message</li><li>Listener.onHalfClose被执行，服务端即将执行我们实现的实际方法，譬如上述的margin方法</li><li>StreamObserver.onNext被调用，代表服务端完成消息处理并将结果返回</li><li>ServerCall.sendHeaders被执行，结果返回时会优先触发Header发送，符合预期</li><li>SeverCall.sendMessage被执行，通过该方法将返回结果投递出去</li><li>StreamObserver.onCompleted/onError被调用，代表业务标识本次请求服务端处理完成或者失败</li><li>ServerCall.close被调用，具体成功失败取决于6</li><li>Listener.onComplete/onCancel，具体成功失败取决于6</li></ol><p>综上我们大致分析一下一个gRPC使用者能够感到的几种API以及他们大致的执行顺序</p><h3><strong>Client部分</strong></h3><p>相比于Server端，Client由于有Stub（例如XXXGrpc.newFutureStub）的缘故，我们不会感知到gRPC内部的API，但为便于大家深入理解，下面将简要介绍一个gRPC请求是如何通过Stub发送以及何时接收到请求的返回。与ServerAPI类似Client同样对应三个API：</p><ol><li>StreamObserver</li><li>ClientCall</li><li>ClientCall.Listener</li></ol><p>StreamObserver跟服务端一样不做介绍，下面着重介绍一下ClientCall及其Listener</p><p>ClientCall代表Client的一次请求，整理其核心API如下:</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ClientCall</span>&lt;<span class=\"hljs-title\">ReqT</span>, <span class=\"hljs-title\">RespT</span>&gt; </span>{\n   \n    <span class=\"hljs-comment\">//顾名思义，代表开启一次请求，这个方法内部会对这个请求相关的内容进行初始化</span>\n    ﻿<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">(Listener responseListener, Metadata headers)</span></span>;    \n    \n    <span class=\"hljs-comment\">//发送数据public abstract void sendMessage(ReqT message);         </span>\n    \n    <span class=\"hljs-comment\">//客户端发送数据完毕，不会再发更多消息</span>\n   ﻿<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">halfClose</span><span class=\"hljs-params\">()</span></span>;      \n    \n    <span class=\"hljs-comment\">//客户端取消本次请求，通常是出现异常或者超时被调用</span>\n﻿    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">cancel</span><span class=\"hljs-params\">(@Nullable String message, @Nullable Throwable cause)</span></span>;\n}\n</pre><p>对应Listener核心API如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Listener</span> {\n\n  <span class=\"hljs-comment\">//代表接收到服务端发送的Headers</span>\n  ﻿<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onHeaders</span>(<span class=\"hljs-params\">Metadata headers</span>)</span> {}\n\n  <span class=\"hljs-comment\">//代表接收到服务端一次请求完整的数据</span>\n  ﻿<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onMessage</span>(<span class=\"hljs-params\">T message</span>)</span> {}\n\n  <span class=\"hljs-comment\">//代表本次请求彻底结束，ListenableFuture的set or setException方法会被执行public void onClose(Status status, Metadata trailers) {}   </span>\n\n}\n</pre><p>下面详细介绍一下客户端发起一次请求大致的流程</p><ol><li>通过用户XXXGrpc.newFutureStub获取的XXXFutureStub调用方法发起请求</li><li>ClientCall.start被调用，客户端创建当前请求相关的Stream及其上下文</li><li>ClientCall.sendMessage被调用，数据被发送到Buffer中等待被投递</li><li>ClientCall.halfClose被调用，代表Client完成本次请求的数据发送不会再进行更多数据发送</li><li>Listener.onHeaders被调用，代表服务端开始回数据，首先获取到Headers</li><li>Listener.onMessage被调用，收到完整的返回数据</li><li>Listener.onClose被调用，代表本次请求结束，最终用户拿到的ListenableFuture会被set，然后用户获取到本次的结果</li></ol><h1><strong>gRPC跟ProtocolBuffers的关系</strong></h1><p>protobuf全名是ProtocolBuffers，是谷歌推出的二进制序列化协议，提供IDL文件来定义各种类型的数据。目前整体协议版本是proto3，protobuf提供了从proto文件编译生成各个语言文件的功能。与此同时protobuf提供了丰富的插件机制，用户可以扩展生成的对应语言的文件，俗称桩代码生成。gRPC正是通过插件式的扩展机制完成相关桩代码的生成。本章会分成如下几个子章节进行展开介绍：</p><ol><li>ProtocolBuffers协议详解</li><li>gRPC桩代码生成</li></ol><h2><strong>ProtocolBuffers协议详解</strong></h2><h3><strong>proto文件几种路径说明</strong></h3><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-attribute\">syntax</span> = <span class=\"hljs-string\">\"proto3\"</span>;\n\n<span class=\"hljs-attribute\">package</span> com.kuaishou.infra.grpc.test;\n\n<span class=\"hljs-attribute\">option</span> java_package = <span class=\"hljs-string\">\"com.kuaishou.demo\"</span>;\n<span class=\"hljs-attribute\">option</span> java_outer_classname = <span class=\"hljs-string\">\"Demo\"</span>;\n<span class=\"hljs-attribute\">option</span> java_multiple_files = <span class=\"hljs-literal\">true</span>;\n\n<span class=\"hljs-attribute\">message</span> TestRequest {\n    <span class=\"hljs-attribute\">string</span> value = <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-attribute\">message</span> TestResponse {\n    <span class=\"hljs-attribute\">string</span> value = <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-attribute\">service</span> TestService {\n    <span class=\"hljs-attribute\">rpc</span> Test (TestRequest) returns (TestResponse);\n    <span class=\"hljs-attribute\">rpc</span> TestDeadline (TestRequest) returns (TestResponse);\n    <span class=\"hljs-attribute\">rpc</span> TestCost (TestRequest) returns (TestResponse);\n    <span class=\"hljs-attribute\">rpc</span> TestEmpty (TestRequest) returns (TestResponse);\n}\n\n<span class=\"hljs-attribute\">service</span> TestStreamService {\n    <span class=\"hljs-attribute\">rpc</span> Test (TestRequest) returns (stream TestResponse);\n    <span class=\"hljs-attribute\">rpc</span> TestFailed (TestRequest) returns (stream TestResponse);\n    <span class=\"hljs-attribute\">rpc</span> TestSlow (TestRequest) returns (stream TestResponse);\n    <span class=\"hljs-attribute\">rpc</span> TestUpStream(stream TestRequest) returns (TestResponse);\n    <span class=\"hljs-attribute\">rpc</span> TestUpStreamSlow(stream TestRequest) returns (TestResponse);\n    <span class=\"hljs-attribute\">rpc</span> TestDuplex(stream TestRequest) returns (stream TestResponse);\n    <span class=\"hljs-attribute\">rpc</span> TestOutboundFlowControl (TestRequest) returns (stream TestResponse);\n}\n\n</pre><p>如上面proto文件所示，一共有三个路径：</p><ol><li>proto文件本身所在路径：假设是kuaishou/demo；使用场景是当其他proto文件需要引入当前proto文件时依赖这个路径，形如 import \"kuaishou/demo/demo.proto\"。这样就可以使用文件内部定义的message了</li><li>proto文件内部package指定路径：com.kuaishou.infra.grpc.test；这个路径非常的核心，任何迁移或者修改proto文件的操作都不应该修改这个package路径，因为它决定了文件内部service的full path name。一旦发生变化就会造成在实际gRPC调用时找不到服务方法而抛异常（Unimplemented）</li><li>option参数指定java输出路径：com.kuaishou.demo；这个路径也比较核心，定义好之后也不要轻易修改，因为它决定了proto中message类的生成路径，如果修改会造成源码不兼容编译阻塞</li></ol><h3><strong>proto文件输出样式</strong></h3><p>proto文件输出样式由如下几个因素决定：</p><ol><li>proto文件的名称，例如infra_demo.proto；在没指定2的前提下，会默认按照驼峰生成OuterClass，对于本例为InfraDemo.java；有意思的是当proto文件中的message跟默认生成java类名重名的时候，会在生成类名后面加上OuterClass，对于本例为InfraDemoOuterClass</li><li>option java_outer_classname = \"Demo\"如果指定此选项，则输出文件名称为指定名称Demo</li><li>option java_multiple_files = true：指定此选项proto文件中的message会生成独立的java文件，此选项定义好后也不要轻易修改，否则也会造成编译阻塞，推荐开启这个选项</li></ol><p><br></p><h2><strong>gRPC桩代码生成</strong></h2><p>gRPC通过Protocol Buffers提供的Plugin机制来实现原生桩代码生成，Protobuf的插件化桩代码生成机制主体思想如下：</p><ol><li>FileDescriptor 作为Plugin的输入参数，代表一个proto文件的描述</li><li class=\"ql-indent-1\">ServiceDescriptor代表一个service的描述符</li><li class=\"ql-indent-1\">MethodDescriptor代表一个service中方法的描述符，包括上面描述的四种MethodType</li><li>Printer作为输出写文件到对应路径</li></ol><h3><strong>gRPC原生桩代码生成</strong></h3><p>gRPC生成的桩代码可以拆解为如下几个部分：</p><ol><li>ServiceDescriptor、MethodDescriptor单例变量，出于性能考虑</li><li>ClientStub，主要包括三种：</li><li class=\"ql-indent-1\">XXXBlockingStub：官方已经弃用</li><li class=\"ql-indent-1\">XXXFutureStub：返回ListeningFuture，也是我们使用最多的方式</li><li class=\"ql-indent-1\">XXXStub：异步方式，业务通过StreamObserver回调来感知数据流转</li><li class=\"ql-indent-1\">XXXImplBase：服务实现基类</li></ol><h3><strong>gRPC桩代码生成扩展</strong></h3><p>gRPC桩代码生成的扩展方式有两种：</p><ol><li>在原生桩代码生成之上做修改，需要修改c++文件重新编译构建，参考Wiki：<a href=\"https://wiki.corp.kuaishou.com/pages/viewpage.action?pageId=267417149\">https://wiki.corp.kuaishou.com/pages/viewpage.action?pageId=267417149</a></li><li>直接利用Protocol Buffers提供的扩展机制自己生成全新的文件，参考Wiki：<a href=\"https://wiki.corp.kuaishou.com/pages/viewpage.action?pageId=226324900\">https://wiki.corp.kuaishou.com/pages/viewpage.action?pageId=226324900</a></li></ol><p><br></p><h1><strong>gRPC是如何跟Netty协作的</strong></h1><p>gRPC跟Netty的关系主要包括如下几方面的依赖：</p><ol><li>依赖Netty实现的HTTP/2协议的封装，通过Listener机制监听HTTP/2的数据报文事件，完成网络相关处理</li><li>Reactor IO模型的依赖，Nio/Epoll</li><li>依赖Netty的ByteBuf完成流数据在内部中的缓存与流转</li></ol><p>本章主要围绕几个方面来详解两者之间是如何互相协作的</p><ol><li>gRPC client侧线程模型</li><li>gRPC server侧线程模型</li><li>gRPC 连接状态机</li></ol><p>在正式介绍本章内容之前，这里先简单科普一下我们常见的几种类型的RPC线程模型</p><h2><strong>几种常见的RPC IO模型</strong></h2><h3><strong>BIO模型（图片来自网络）</strong></h3><img width=\"900\" id=\"6sdslyod\" src=\"https://kstack.corp.kuaishou.com/tech/api/file/5eb2e439-1051-4415-9f00-1c119d864784?alt=auto\"><p>主要特点</p><ol><li>每个请求一个IO线程处理</li><li>Client消息请求与应答由IO线程完成</li><li>IO线程在没有处理完之前会同步阻塞</li></ol><p>优点</p><ol><li>想啥呢？ 没啥优点</li></ol><p>缺点</p><ol><li>吞吐低：每个请求一个线程很容易导致server端出现资源瓶颈从而影响吞吐，频繁创建线程也不能合理利用线程资源（可以通过使用线程池来解决）</li><li>稳定性：由于是阻塞模型，遇到网络抖动就凉了</li><li>可维护性：IO线程数无法预估，资源利用率低</li></ol><h3><strong>NIO模型（图片来自网络）</strong></h3><img width=\"900\" id=\"cgcmivtk\" src=\"https://kstack.corp.kuaishou.com/tech/api/file/52b2e0a8-cccb-463a-a1df-34ab7864dd0b?alt=auto\"><p>俗称IO多路复用模型，该线程模型中前端挂载一个Selector用于轮询各个Channel的IO事件，收到后Dispatch到后端Worker线程池去做实际的IO处理（读写等），Worker线程池可以有多种模式，取决于具体设计</p><p>主要特点</p><ol><li>IO多路复用</li><li>非阻塞</li></ol><p>优点</p><ol><li>IO非阻塞，可靠性和效率都相应提高</li></ol><p>缺点</p><ol><li>轮询的效率可能不高，取决于底层使用的系统库函数（select/poll）</li><li>内存拷贝相关还是会阻塞</li></ol><p><br></p><h3><strong>AIO模型</strong></h3><p>AIO模型跟NIO模型本质的区别是异步，这里异步的含义是指当数据处理完成之后才通知使用方，而NIO是数据就绪之后</p><h3><strong>RPC性能三要素</strong></h3><ol><li>IO模型：决定了数据发送的效率，可靠性等</li><li>协议：通常内部协议性能会更优</li><li>线程模型：决定编解码、消息接收与返回等在哪个线程执行</li></ol><h2><strong>gRPC client侧线程模型</strong></h2><p>gRPC client端可以划分出三种线程</p><ol><li>Caller线程：业务当前线程</li><li>Worker线程（<span style=\"background-color: rgba(255, 255, 255, 0.01); color: rgb(50, 50, 50);\">grpc-default-executor</span>）：请求处理与响应回调线程</li><li>IO线程（grpc-nio-worker-ELG）：使用Netty的ELG</li></ol><p>以futureClient为例，一次client请求的线程切换如下图：</p><p><br></p><img width=\"1806\" id=\"jefl0cu8\" src=\"https://kstack.corp.kuaishou.com/tech/api/file/f37b25ea-caed-45d7-b06e-6e442a5ae552?alt=auto\"><p><br></p><p>整体一次执行流程描述如下：</p><ol><li>创建链接，通常是Delayed的模式，第一次创建Stream时候之前才会创建连接</li><li>创建Stream，代表发起一次请求，在Caller Thread完成</li><li>发送Header，将Header Frame投递到WriteQueue，Call Thread完成，ELG异步消费WriteQueue</li><li>发送Message，将Message Frame投递到WriteQueue，Call Thread完成，ELG异步消费WriteQueue</li><li>接收Header，这里完成一次从ELG -&gt; Worker线程池的切换，需要注意的是如果创建Client时我们指定了directExecutor模式，那么将统一由ELG线程完成</li><li>接收Message，这里完成一次从ELG -&gt; Worker线程池的切换，需要注意的是如果创建Client时我们指定了directExecutor模式，那么将统一由ELG线程完成</li><li>接收关闭Stream请求，线程切换同5，6，最终会回调Future的set方法</li><li>Caller Thread通过Future.get获取到结果</li></ol><p><br></p><h2><strong>gRPC server侧线程模型</strong></h2><p>gRPC server侧主要包括两个线程：</p><ol><li>Worker线程（grpc-default-executor）：Server启动时候指定</li><li>IO线程（grpc-nio-worker-ELG）：使用Netty的ELG</li></ol><p>以一次Unary请求为例，Server侧线程切换如下：</p><p><br></p><img width=\"2198\" id=\"4h8rjhga\" src=\"https://kstack.corp.kuaishou.com/tech/api/file/90feb24b-6e73-4949-988c-1e37d94505dd?alt=auto\"><p><br></p><p>整体一次执行流程描述如下：</p><ol><li>接收Client发送的创建Stream的请求，ELG -&gt; Worker线程切换，最终创建一个ServerCall及其Listener</li><li>接收Client发送的Msg，ELG -&gt; Worker线程切换，反序列化保存</li><li>Client完成发送，ELG -&gt; Worker线程切换，回调Server业务逻辑</li><li>处理完成发送Header，扔到WriteQueue，ELG异步消费发送Header Frame到Client</li><li>处理完成发送Message，扔到WriteQueue，ELG异步消费发送Message Frame到Client</li><li>完成全部消息发送，标记end<em>of</em>frame，对于unary而言跟5合成一步，扔到WriteQueue，ELG异步消费发送Message Frame到Client</li><li>Client发送RstStream请求，并不一定会发送，取决于配置，回调Listener</li></ol><p><br></p><p>综上完成了Client与Server线程模型的介绍，结合第一章API设计思路部分，相信大家可以更好的理解一次请求在gRPC内部是如何流转的。下面将介绍一个连接从建立到释放状态流转的过程，从另一种维度介绍gRPC是如何维护连接的。</p><h2><strong>gRPC连接状态机</strong></h2><p>gRPC内部在Channel构建到销毁的生命周期内，维护了该链接的整个状态的运转，了解内部具体的运转流程有助于我们更好的定位问题。gRPC内部链接主要分成如下几个状态：</p><ol><li>CONNECTING：代表Channel正在初始化建立连接，流程会涉及DNS解析、TCP建连、TLS握手等</li><li>READY：成功建立连接，包括HTTP2协商，代表Channel可以正常收发数据</li><li><span style=\"color: rgb(36, 41, 46);\">TRANSIENT_FAILURE：建连失败或者CS之间网络问题导致，Channel最终会重新发起建立连接请求，gRPC提供了一套backoff Retry机制来保证不会出现重连风暴</span></li><li><span style=\"color: rgb(36, 41, 46);\">IDLE：Channel中长期没有请求或收到HTTP2的GO_AWAY信号会进入此状态，此时CS之间连接已经断开，一旦新请求发起会转移到CONNECTING。主要目的是保障SERVER连接数不会太大造成压力</span></li><li><span style=\"color: rgb(36, 41, 46);\">SHUTDOWN：Channel已经关闭，状态不可逆，新请求会立即失败掉，排队的请求会继续处理完</span></li></ol><p>下图描述了五种状态之间的转换：</p><img width=\"1300\" id=\"560g0y0w\" src=\"https://kstack.corp.kuaishou.com/tech/api/file/3e3a571b-3a5e-405c-bab1-811795dad331?alt=auto\"><p><br></p><h1><br></h1><h1><strong>gRPC常见异常类型与分析</strong></h1><p>跟其他常见RPC框架类似，RPC内部提供了一套状态码用来描述RPC请求的执行情况。本章会介绍各个状态码的含义以及对应的常见异常，并提供相应的处理方式。</p><h2><strong>gRPC常见状态码</strong></h2><p>如下链接给出gRPC全部状态码及其解释说明</p><p><a href=\"https://github.com/grpc/grpc/blob/master/doc/statuscodes.md\">https://github.com/grpc/grpc/blob/master/doc/statuscodes.md</a></p><p>从中选取一些大家会遇到的进行简单描述</p><ol><li><strong>OK</strong>：代表请求成功执行</li><li><strong>CANCELLED：</strong>请求被取消，通常是超时 or Deadline Exceed导致</li><li><strong>UNKNOWN</strong>：通常是Server抛异常导致，一般Server业务执行抛异常非StatusException or RuntimeStatusException，所以gRPC内部会用UNKNOWN状态码进行处理</li><li><strong>DEADLINE_EXCEEDED：</strong>客户端请求配置了withDeadlineAfter CallOption，双端都生效，服务端超时会取消请求，Client侧表现为收到这个状态码的RuntimeStatusException，也是我们最常见的异常</li><li><strong>PERMISSION_DENIED：</strong>顾名思义，代表没有访问权限，可以对应HTTP的403，常见如IP白名单</li><li><strong>UNAUTHENTICATED：</strong>gRPC特意用这个状态码代表没有授权的访问，通常是开启tls的服务</li><li><strong>RESOURCE_EXAUSTED：</strong>代表服务端资源不足，如带宽，磁盘，连接数等等；业务也可以使用它来描述业务资源不足的情况</li><li><strong>UNIMPLEMENTED：</strong>gRPC内部异常，请求的FullPath方法未实现，如果没有FallbackRegistry会抛这个状态码异常，通常可能是proto文件有不兼容改动</li><li><strong>UNAVAILABLE：</strong>代表当前服务不可用，一般是暂时性问题，代表客户端可以通过重试来解决的情况</li><li><strong>INTERNAL：</strong>gRPC内部严重错误，通常是有严重bug才会出现，业务不应该使用此状态码</li></ol><h2><strong>gRPC常见异常与分析</strong></h2><h3><strong>INTERNAL</strong></h3><p><br></p><p><strong>Case 1: Shade包导致SPI加载问题</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">Caused by: java.lang.IllegalStateException: Could <span class=\"hljs-keyword\">not</span> find policy <span class=\"hljs-string\">'pick_first'</span>. Make sure its implementation <span class=\"hljs-keyword\">is</span> either registered to LoadBalancerRegistry <span class=\"hljs-keyword\">or</span> included <span class=\"hljs-keyword\">in</span> META-INF/services/io.grpc.LoadBalancerProvider <span class=\"hljs-keyword\">from</span> your jar files.\nz\n</pre><p>这个case通常是使用shade包的工程，在打包时候改变了gRPC的SPI实现的路径名，导致找不到实际实现所以出现上述异常，解决方案如下：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">executions</span>&gt;&lt;<span class=\"hljs-name\">execution</span>&gt;&lt;<span class=\"hljs-name\">goals</span>&gt;&lt;<span class=\"hljs-name\">goal</span>&gt;</span>shadegoal&gt;goals&gt;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;&lt;<span class=\"hljs-name\">transformers</span>&gt;&lt;<span class=\"hljs-name\">transformer</span> <span class=\"hljs-attr\">implementation</span>=<span class=\"hljs-string\">\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\"</span>/&gt;</span>transformers&gt;configuration&gt;execution&gt;\nexecutions&gt;\n</pre><p>在shade plugin中加入上述transformer来解决即可</p><p><br></p><p><strong>Case 2: 服务端忘记结束请求</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">io.grpc.StatusRuntimeException: INTERNAL: No value received for unary <span class=\"hljs-keyword\">call</span>\n\t<span class=\"hljs-keyword\">at</span> io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:<span class=\"hljs-number\">210</span>)\n\t<span class=\"hljs-keyword\">at</span> io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:<span class=\"hljs-number\">191</span>)\n\t<span class=\"hljs-keyword\">at</span> io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:<span class=\"hljs-number\">124</span>)\n\t<span class=\"hljs-keyword\">at</span> com.dd.search.rpc.stub.SearchServiceGrpc$SearchServiceBlockingStub.getResourcesList(SearchServiceGrpc.java:<span class=\"hljs-number\">298</span>)\n\t<span class=\"hljs-keyword\">at</span> com.dd.search.grpc.client.GrpcSearchClientService.getResourcesList(GrpcSearchClientService.java:<span class=\"hljs-number\">102</span>)\n\t<span class=\"hljs-keyword\">at</span> com.dd.search.grpc.client.GrpcSearchClientController.getResourcesList(GrpcSearchClientController.java:<span class=\"hljs-number\">26</span>)\n\t<span class=\"hljs-keyword\">at</span> sun.reflect.NativeMethodAccessorImpl.invoke0(<span class=\"hljs-keyword\">Native</span> Method)\n\t<span class=\"hljs-keyword\">at</span> sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class=\"hljs-number\">62</span>)\n\t<span class=\"hljs-keyword\">at</span> sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class=\"hljs-number\">43</span>)\n\t<span class=\"hljs-keyword\">at</span> java.lang.reflect.Method.invoke(Method.java:<span class=\"hljs-number\">498</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:<span class=\"hljs-number\">205</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:<span class=\"hljs-number\">133</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:<span class=\"hljs-number\">97</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:<span class=\"hljs-number\">827</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:<span class=\"hljs-number\">738</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:<span class=\"hljs-number\">85</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:<span class=\"hljs-number\">967</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:<span class=\"hljs-number\">901</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:<span class=\"hljs-number\">970</span>)\n\t<span class=\"hljs-keyword\">at</span> org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:<span class=\"hljs-number\">861</span>)\n\t<span class=\"hljs-keyword\">at</span> javax.servlet.http.HttpServlet.service(HttpServlet.java:<span class=\"hljs-number\">635</span>)\n</pre><p>这个case通常是服务端问题导致，服务端一直没有回调onComplete or onError，所以client表现为拿不到结果，另外已经不建议继续使用BlockingStub，官方也已经Deprecated掉</p><p><br></p><p><strong>Case 3：收到无法识别的Stream的报文</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-attr\">WARNING</span>: <span class=\"hljs-string\">Stream Error</span>\n<span class=\"hljs-meta\">io.netty.handler.codec.http2.Http2Exception$StreamException</span>: <span class=\"hljs-string\">Received DATA frame for an unknown stream 2001</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:129)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.shouldIgnoreHeadersOrDataFrame(DefaultHttp2ConnectionDecoder.java:535)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder$FrameReadListener.onDataRead(DefaultHttp2ConnectionDecoder.java:187)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.Http2InboundFrameLogger$1.onDataRead(Http2InboundFrameLogger.java:48)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.DefaultHttp2FrameReader.readDataFrame(DefaultHttp2FrameReader.java:421)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:251)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:118)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:390)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:450)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1434)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:965)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:808)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:408)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:297)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:884)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.lang.Thread.run(Thread.java:748)</span>\n</pre><p>该异常在不频繁的情况下是正常现象，通常是由Client发起Cancel导致，可能是DEADLINE_EXCEED或者是TimeoutCancel（取决于是否开启该功能），如果频繁出现可以咨询基础架构同学</p><p><br></p><p><strong>Case 4：Stream提前关闭，导致Server抛异常</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-number\">2019</span>-08-<span class=\"hljs-number\">27</span> <span class=\"hljs-number\">18</span>:<span class=\"hljs-number\">39</span>:<span class=\"hljs-number\">34</span>,<span class=\"hljs-number\">155</span> WARN  [grpc-nio-worker-ELG-<span class=\"hljs-number\">3</span>-<span class=\"hljs-number\">1</span>] i.g.n.s.i.g.n.NettyServerHandler: Stream Error\nio.grpc.netty.shaded.io.netty.handler.codec.http2.Http2Exception$StreamException: Stream closed before <span class=\"hljs-keyword\">write</span> could take placeat io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:<span class=\"hljs-number\">167</span>)at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$FlowState.cancel(DefaultHttp2RemoteFlowController.java:<span class=\"hljs-number\">481</span>)at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2RemoteFlowController$1.onStreamClosed(DefaultHttp2RemoteFlowController.java:<span class=\"hljs-number\">105</span>)at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2Connection.notifyClosed(DefaultHttp2Connection.java:<span class=\"hljs-number\">356</span>)at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.removeFromActiveStreams(DefaultHttp2Connection.java:<span class=\"hljs-number\">1000</span>)at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2Connection$ActiveStreams.deactivate(DefaultHttp2Connection.java:<span class=\"hljs-number\">956</span>)at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2Connection$DefaultStream.close(DefaultHttp2Connection.java:<span class=\"hljs-number\">512</span>)at io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2Connection.close(DefaultHttp2Connection.java:<span class=\"hljs-number\">152</span>)at io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2ConnectionHandler$BaseDecoder.channelInactive(Http2ConnectionHandler.java:<span class=\"hljs-number\">209</span>)at io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2ConnectionHandler.channelInactive(Http2ConnectionHandler.java:<span class=\"hljs-number\">417</span>)at io.grpc.netty.shaded.io.grpc.netty.NettyServerHandler.channelInactive(NettyServerHandler.java:<span class=\"hljs-number\">586</span>)at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">257</span>)at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">243</span>)at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">236</span>)at io.grpc.netty.shaded.io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:<span class=\"hljs-number\">1416</span>)at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">257</span>)at io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">243</span>)at io.grpc.netty.shaded.io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:<span class=\"hljs-number\">912</span>)at io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:<span class=\"hljs-number\">816</span>)at io.grpc.netty.shaded.io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:<span class=\"hljs-number\">163</span>)at io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:<span class=\"hljs-number\">416</span>)at io.grpc.netty.shaded.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:<span class=\"hljs-number\">515</span>)at io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:<span class=\"hljs-number\">918</span>)at io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:<span class=\"hljs-number\">74</span>)at io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:<span class=\"hljs-number\">30</span>)at java.base/java.lang.Thread.run(Thread.java:<span class=\"hljs-number\">834</span>)\n</pre><p>这个case跟上面的类似，都是由于一些原因导致Stream已经关闭，Server端回数据的时候无法识别，通常可能是Server的WriteQueue有堆积或者业务处理过慢；还有极端case是Client突然被kill了也可能会导致这个问题</p><p>附赠官方ISSUE：<a href=\"https://github.com/grpc/grpc-java/issues/1578\">https://github.com/grpc/grpc-java/issues/1578</a></p><p><br></p><h3><strong>RESOURCE_EXAUSTED</strong></h3><p><strong>CASE 1: 超过消息最大限制</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-attr\">WARNING</span>: <span class=\"hljs-string\">Exception processing message</span>\n<span class=\"hljs-meta\">io.grpc.StatusRuntimeException</span>: <span class=\"hljs-string\">RESOURCE_EXHAUSTED: io.grpc.netty.NettyServerStream$TransportState: Frame size 59000005 exceeds maximum: 4194304. </span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.Status.asRuntimeException(Status.java:517)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.MessageDeframer.processHeader(MessageDeframer.java:391)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.MessageDeframer.deliver(MessageDeframer.java:271)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.MessageDeframer.request(MessageDeframer.java:165)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.AbstractStream$TransportState.requestMessagesFromDeframer(AbstractStream.java:202)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.NettyServerStream$Sink$1.run(NettyServerStream.java:100)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:403)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.lang.Thread.run(Thread.java:745)</span>\n</pre><p>顾名思义Message Size超过了Channel配置的max message size，需要业务自己调整大小或结合业务场景改成流式调用；针对这点基础架构这边有相应监控跟warnlog来提示业务方</p><p><br></p><h3><strong>UKNOWN</strong></h3><p><strong>Case 1：Server抛异常</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-meta\">io.grpc.StatusRuntimeException</span>: <span class=\"hljs-string\">UNKNOWN</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.Status.asRuntimeException(Status.java:545)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:395)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.close(ClientCallImpl.java:481)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.access$600(ClientCallImpl.java:398)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:513)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.SerializingExecutor$TaskRunner.run(SerializingExecutor.java:154)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.lang.Thread.run(Thread.java:745)</span>\n</pre><p>这种没有特殊message提示的基本上都是服务端抛了一个异常，咨询对应服务负责人处理即可</p><p><br></p><p>Case 2：</p><p><br></p><h3><strong>UNAVAILABLE</strong></h3><p><strong>Case 1：网络异常</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">io.grpc.StatusRuntimeException: UNAVAILABLE: io exception\n</pre><p>通常是网络问题，Client跟Server的链接已经断开，Channel可能进入Transient Failure状态，短时间出现这个问题可能是网络抖动造成，如果长期不恢复需要排查一下具体原因</p><p><br></p><p>Case 2：gRPC低版本bug，在1.23.0之后的高版本均修复</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-meta\">com.google.api.gax.rpc.UnavailableException</span>: <span class=\"hljs-string\">io.grpc.StatusRuntimeException: UNAVAILABLE: Connection closed while performing protocol negotiation for [HttpClientCodec#0, HttpProxyHandler#0, ProtocolNegotiators$WaitUntilActiveHandler#0, WriteBufferingAndExceptionHandler#0, DefaultChannelPipeline$TailContext#0]</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.api.gax.rpc.ApiExceptionFactory.createException(ApiExceptionFactory.java:69)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.api.gax.grpc.GrpcApiExceptionFactory.create(GrpcApiExceptionFactory.java:72)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.api.gax.grpc.GrpcApiExceptionFactory.create(GrpcApiExceptionFactory.java:60)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.api.gax.grpc.GrpcExceptionCallable$ExceptionTransformingFuture.onFailure(GrpcExceptionCallable.java:97)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.api.core.ApiFutures$1.onFailure(ApiFutures.java:68)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.common.util.concurrent.Futures$CallbackListener.run(Futures.java:1015)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.common.util.concurrent.DirectExecutor.execute(DirectExecutor.java:30)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.common.util.concurrent.AbstractFuture.executeListener(AbstractFuture.java:1137)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.common.util.concurrent.AbstractFuture.complete(AbstractFuture.java:957)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.common.util.concurrent.AbstractFuture.setException(AbstractFuture.java:748)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.stub.ClientCalls$GrpcFuture.setException(ClientCalls.java:515)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.stub.ClientCalls$UnaryStreamToFuture.onClose(ClientCalls.java:490)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.PartialForwardingClientCallListener.onClose(PartialForwardingClientCallListener.java:39)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.ForwardingClientCallListener.onClose(ForwardingClientCallListener.java:23)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.ForwardingClientCallListener$SimpleForwardingClientCallListener.onClose(ForwardingClientCallListener.java:40)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.ads.googleads.lib.logging.LoggingInterceptor$1$1.onClose(LoggingInterceptor.java:111)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.PartialForwardingClientCallListener.onClose(PartialForwardingClientCallListener.java:39)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.ForwardingClientCallListener.onClose(ForwardingClientCallListener.java:23)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.ForwardingClientCallListener$SimpleForwardingClientCallListener.onClose(ForwardingClientCallListener.java:40)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.CensusStatsModule$StatsClientInterceptor$1$1.onClose(CensusStatsModule.java:700)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.PartialForwardingClientCallListener.onClose(PartialForwardingClientCallListener.java:39)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.ForwardingClientCallListener.onClose(ForwardingClientCallListener.java:23)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.ForwardingClientCallListener$SimpleForwardingClientCallListener.onClose(ForwardingClientCallListener.java:40)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.CensusTracingModule$TracingClientInterceptor$1$1.onClose(CensusTracingModule.java:399)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:510)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ClientCallImpl.access$300(ClientCallImpl.java:66)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.close(ClientCallImpl.java:630)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.access$700(ClientCallImpl.java:518)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInternal(ClientCallImpl.java:692)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:681)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:123)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.util.concurrent.FutureTask.run(FutureTask.java:266)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.lang.Thread.run(Thread.java:745)</span>\n<span class=\"hljs-attr\">Suppressed</span>: <span class=\"hljs-string\">com.google.api.gax.rpc.AsyncTaskException: Asynchronous task failed</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.api.gax.rpc.ApiExceptions.callAndTranslateApiException(ApiExceptions.java:57)</span>\n<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">com.google.api.gax.rpc.UnaryCallable.call(UnaryCallable.java:112)</span>\n</pre><p>参考相关issue：<a href=\"https://github.com/grpc/grpc-java/issues/6118\">https://github.com/grpc/grpc-java/issues/6118</a></p><h3><strong>NETTY相关</strong></h3><p><br></p><p>CASE 1：</p><pre class=\"ql-syntax\" spellcheck=\"false\">2019-11-18 14:22:10.002 WARN grpc-default-worker-ELG-1-10 (ReferenceCountUtil.java:115) - Failed to <span class=\"hljs-keyword\">release</span> a message: UnpooledSlicedByteBuf(freed)\nio.grpc.netty.shaded.io.netty.util.IllegalReferenceCountException: refCnt: <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">decrement</span>: <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.util.internal.ReferenceCountUpdater.toLiveRealRefCnt(ReferenceCountUpdater.java:<span class=\"hljs-number\">74</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.util.internal.ReferenceCountUpdater.release(ReferenceCountUpdater.java:<span class=\"hljs-number\">138</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:<span class=\"hljs-number\">100</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.buffer.CompositeByteBuf$Component.free(CompositeByteBuf.java:<span class=\"hljs-number\">1908</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.buffer.CompositeByteBuf.deallocate(CompositeByteBuf.java:<span class=\"hljs-number\">2217</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf.handleRelease(AbstractReferenceCountedByteBuf.java:<span class=\"hljs-number\">110</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:<span class=\"hljs-number\">100</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.buffer.AbstractDerivedByteBuf.release0(AbstractDerivedByteBuf.java:<span class=\"hljs-number\">94</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.buffer.AbstractDerivedByteBuf.release(AbstractDerivedByteBuf.java:<span class=\"hljs-number\">90</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:<span class=\"hljs-number\">88</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.util.ReferenceCountUtil.safeRelease(ReferenceCountUtil.java:<span class=\"hljs-number\">113</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:<span class=\"hljs-number\">269</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:<span class=\"hljs-number\">350</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.epoll.AbstractEpollStreamChannel.writeBytesMultiple(AbstractEpollStreamChannel.java:<span class=\"hljs-number\">305</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.epoll.AbstractEpollStreamChannel.doWriteMultiple(AbstractEpollStreamChannel.java:<span class=\"hljs-number\">510</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.epoll.AbstractEpollStreamChannel.doWrite(AbstractEpollStreamChannel.java:<span class=\"hljs-number\">422</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:<span class=\"hljs-number\">928</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.flush0(AbstractEpollChannel.java:<span class=\"hljs-number\">514</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:<span class=\"hljs-number\">895</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:<span class=\"hljs-number\">1383</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">749</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">741</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">727</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2ConnectionHandler.flush(Http2ConnectionHandler.java:<span class=\"hljs-number\">189</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">749</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">741</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:<span class=\"hljs-number\">727</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.DefaultChannelPipeline.flush(DefaultChannelPipeline.java:<span class=\"hljs-number\">978</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.AbstractChannel.flush(AbstractChannel.java:<span class=\"hljs-number\">241</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.grpc.netty.WriteQueue.flush(WriteQueue.java:<span class=\"hljs-number\">134</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.grpc.netty.WriteQueue.access$<span class=\"hljs-number\">000</span>(WriteQueue.java:<span class=\"hljs-number\">34</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.grpc.netty.WriteQueue$<span class=\"hljs-number\">1.</span>run(WriteQueue.java:<span class=\"hljs-number\">46</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:<span class=\"hljs-number\">163</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:<span class=\"hljs-number\">416</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:<span class=\"hljs-number\">331</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$<span class=\"hljs-number\">5.</span>run(SingleThreadEventExecutor.java:<span class=\"hljs-number\">918</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$<span class=\"hljs-number\">2.</span>run(ThreadExecutorMap.java:<span class=\"hljs-number\">74</span>)\n<span class=\"hljs-keyword\">at</span> io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:<span class=\"hljs-number\">30</span>)\n<span class=\"hljs-keyword\">at</span> java.lang.Thread.run(Thread.java:<span class=\"hljs-number\">745</span>)\n</pre><p>Client如果出现这种情况，大概率是Server并发调用onNext导致，通常会出现StreamingServer的情况，由于本身是Warn级别并不会造成太大影响，相关问题可以咨询我</p><p>参考这个issue：<a href=\"https://github.com/grpc/grpc-java/issues/1905\">https://github.com/grpc/grpc-java/issues/1905</a></p><p>CASE 2:</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-meta\">2019-11-29</span> <span class=\"hljs-string\">12:46:53.094 WARN&nbsp; &nbsp; &nbsp;grpc-default-worker-ELG-1-7 (NettyServerHandler.java:519) - Stream Error</span>\n<span class=\"hljs-meta\">io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2Exception$StreamException</span>: <span class=\"hljs-string\">Pseudo-header field ':path' found after regular header.</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2Exception.streamError(Http2Exception.java:147)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.HpackDecoder.validate(HpackDecoder.java:387)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.HpackDecoder.access$000(HpackDecoder.java:54)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.HpackDecoder$Http2HeadersSink.appendToHeaderList(HpackDecoder.java:564)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.HpackDecoder.decode(HpackDecoder.java:163)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.HpackDecoder.decode(HpackDecoder.java:129)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2HeadersDecoder.decodeHeaders(DefaultHttp2HeadersDecoder.java:126)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2FrameReader$HeadersBlockBuilder.headers(DefaultHttp2FrameReader.java:743)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2FrameReader$1.processFragment(DefaultHttp2FrameReader.java:457)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2FrameReader.readHeadersFrame(DefaultHttp2FrameReader.java:464)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2FrameReader.processPayloadState(DefaultHttp2FrameReader.java:254)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2FrameReader.readFrame(DefaultHttp2FrameReader.java:160)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2InboundFrameLogger.readFrame(Http2InboundFrameLogger.java:41)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.DefaultHttp2ConnectionDecoder.decodeFrame(DefaultHttp2ConnectionDecoder.java:174)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2ConnectionHandler$FrameDecoder.decode(Http2ConnectionHandler.java:378)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.http2.Http2ConnectionHandler.decode(Http2ConnectionHandler.java:438)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:444)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1421)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:794)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:424)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:326)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">io.grpc.netty.shaded.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span>\n\t<span class=\"hljs-attr\">at</span> <span class=\"hljs-string\">java.base/java.lang.Thread.run(Thread.java:834)</span>\n</pre><p>如上异常表示当前Stream（请求）没有遵循HTTP2的SPEC，具体要求如下：</p><p>All pseudo-header fields MUST appear in the header block before regular header fields. Any request or response that contains a pseudo-header field that appears in a header block after a regular header field MUST be treated as malformed (Section 8.1.2.6)</p><p>导致的原因通常是gRPC升级之后不兼容或者滥用header传递信息导致，相关问题请咨询基础架构组</p><p><br></p><h3><strong>资源泄露相关</strong></h3><p>CASE 1: 看到这个异常栈请联系基础架构组，通常代表channel没有被正常关闭</p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-number\">2019-11-28</span> <span class=\"hljs-number\">13</span>:<span class=\"hljs-number\">19</span>:<span class=\"hljs-number\">26.109</span> <span class=\"hljs-function\">ERROR&nbsp; &nbsp; <span class=\"hljs-title\">recoRealTimeIndexTagBatchUpdateCandidateThread0</span> (<span class=\"hljs-params\">ManagedChannelOrphanWrapper.java:<span class=\"hljs-number\">151</span></span>) - *~*~*~ Channel ManagedChannelImpl</span>{logId=<span class=\"hljs-number\">13</span>, target=directaddress:<span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>/12</span>\n<span class=\"hljs-number\">7.0.0.1</span>:<span class=\"hljs-number\">6608</span>} was not shutdown properly!!! ~*~*~*\n&nbsp; &nbsp; <span class=\"hljs-function\">Make sure to call <span class=\"hljs-title\">shutdown</span>()/<span class=\"hljs-title\">shutdownNow</span>() and wait until <span class=\"hljs-title\">awaitTermination</span>() returns <span class=\"hljs-literal\">true</span>.\njava.lang.RuntimeException: ManagedChannel allocation site\n&nbsp; &nbsp; &nbsp; &nbsp; at io.grpc.<span class=\"hljs-keyword\">internal</span>.ManagedChannelOrphanWrapper$ManagedChannelReference.(<span class=\"hljs-params\">ManagedChannelOrphanWrapper.java:<span class=\"hljs-number\">94</span></span>)\n&nbsp; &nbsp; &nbsp; &nbsp; at io.grpc.<span class=\"hljs-keyword\">internal</span>.ManagedChannelOrphanWrapper.(<span class=\"hljs-params\">ManagedChannelOrphanWrapper.java:<span class=\"hljs-number\">52</span></span>)\n&nbsp; &nbsp; &nbsp; &nbsp; at io.grpc.<span class=\"hljs-keyword\">internal</span>.ManagedChannelOrphanWrapper.(<span class=\"hljs-params\">ManagedChannelOrphanWrapper.java:<span class=\"hljs-number\">43</span></span>)\n&nbsp; &nbsp; &nbsp; &nbsp; at io.grpc.<span class=\"hljs-keyword\">internal</span>.AbstractManagedChannelImplBuilder.<span class=\"hljs-title\">build</span>(<span class=\"hljs-params\">AbstractManagedChannelImplBuilder.java:<span class=\"hljs-number\">512</span></span>)\n</span></pre>
